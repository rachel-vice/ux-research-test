'use strict';

var instrumentation = require('@opentelemetry/instrumentation');
var resources = require('@opentelemetry/resources');
var sdkTraceBase = require('@opentelemetry/sdk-trace-base');
var sdkTraceWeb = require('@opentelemetry/sdk-trace-web');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var opentelemetryBrowserDetector = require('@opentelemetry/opentelemetry-browser-detector');
var UAParser = require('ua-parser-js');
var api = require('@opentelemetry/api');
var exporterTraceOtlpHttp = require('@opentelemetry/exporter-trace-otlp-http');
var core = require('@opentelemetry/core');
var shimmer = require('shimmer');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var shimmer__namespace = /*#__PURE__*/_interopNamespaceDefault(shimmer);

// This code will eventually be packaged upstream into a WebSDK package.
// Once it is released as a package, this distro will depend directly on the upstream package.
// https://github.com/open-telemetry/opentelemetry-js/pull/4325
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SESSION_ID_BYTES = 16;
const SHARED_CHAR_CODES_ARRAY = Array(32);
class SessionIdSpanProcessor {
  constructor() {
    this._idGenerator = getIdGenerator(SESSION_ID_BYTES);
    this._sessionId = this._idGenerator();
  }
  onStart(span) {
    span.setAttribute('session.id', this._sessionId);
  }
  onEnd() {}
  forceFlush() {
    return Promise.resolve();
  }
  shutdown() {
    return Promise.resolve();
  }
}
function getIdGenerator(bytes) {
  return function generateId() {
    for (let i = 0; i < bytes * 2; i++) {
      SHARED_CHAR_CODES_ARRAY[i] = Math.floor(Math.random() * 16) + 48;
      // valid hex characters in the range 48-57 and 97-102
      if (SHARED_CHAR_CODES_ARRAY[i] >= 58) {
        SHARED_CHAR_CODES_ARRAY[i] += 39;
      }
    }
    return String.fromCharCode.apply(null, SHARED_CHAR_CODES_ARRAY.slice(0, bytes * 2));
  };
}

// This code will eventually be packaged upstream into a WebSDK package.
// Once it is released as a package, this distro will depend directly on the upstream package.
// https://github.com/open-telemetry/opentelemetry-js/pull/4325
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** This class represents everything needed to register a fully configured OpenTelemetry Web SDK */
class WebSDK {
  /**
   * Create a new Web SDK instance
   */
  constructor(configuration = {}) {
    var _a, _b, _c, _d;
    this._resource = (_a = configuration.resource) !== null && _a !== void 0 ? _a : new resources.Resource({});
    this._resourceDetectors = (_b = configuration.resourceDetectors) !== null && _b !== void 0 ? _b : [opentelemetryBrowserDetector.browserDetector];
    this._serviceName = configuration.serviceName;
    this._autoDetectResources = (_c = configuration.autoDetectResources) !== null && _c !== void 0 ? _c : true;
    if (configuration.spanProcessor || configuration.traceExporter) {
      const tracerProviderConfig = {};
      if (configuration.sampler) {
        tracerProviderConfig.sampler = configuration.sampler;
      }
      if (configuration.spanLimits) {
        tracerProviderConfig.spanLimits = configuration.spanLimits;
      }
      if (configuration.idGenerator) {
        tracerProviderConfig.idGenerator = configuration.idGenerator;
      }
      const spanProcessor = (_d = configuration.spanProcessor) !== null && _d !== void 0 ? _d : new sdkTraceBase.BatchSpanProcessor(configuration.traceExporter);
      this._tracerProviderConfig = {
        tracerConfig: tracerProviderConfig,
        spanProcessor,
        contextManager: configuration.contextManager,
        textMapPropagator: configuration.textMapPropagator
      };
    }
    let instrumentations = [];
    if (configuration.instrumentations) {
      instrumentations = configuration.instrumentations;
    }
    this._instrumentations = instrumentations;
  }
  /**
   * Call this method to construct SDK components and register them with the OpenTelemetry API.
   */
  start() {
    var _a, _b, _c;
    if (this._disabled) {
      return;
    }
    instrumentation.registerInstrumentations({
      instrumentations: this._instrumentations
    });
    if (this._autoDetectResources) {
      const internalConfig = {
        detectors: this._resourceDetectors
      };
      this._resource = this._resource.merge(resources.detectResourcesSync(internalConfig));
    }
    this._resource = this._serviceName === undefined ? this._resource : this._resource.merge(new resources.Resource({
      [semanticConventions.SEMRESATTRS_SERVICE_NAME]: this._serviceName
    }));
    const tracerProvider = new sdkTraceWeb.WebTracerProvider(Object.assign(Object.assign({}, (_a = this._tracerProviderConfig) === null || _a === void 0 ? void 0 : _a.tracerConfig), {
      resource: this._resource
    }));
    this._tracerProvider = tracerProvider;
    if (this._tracerProviderConfig) {
      tracerProvider.addSpanProcessor(this._tracerProviderConfig.spanProcessor);
    }
    tracerProvider.register({
      contextManager: (_b = this._tracerProviderConfig) === null || _b === void 0 ? void 0 : _b.contextManager,
      propagator: (_c = this._tracerProviderConfig) === null || _c === void 0 ? void 0 : _c.textMapPropagator
    });
    // add processor for adding the sessionId attribute
    tracerProvider.addSpanProcessor(new SessionIdSpanProcessor());
  }
  /* Experimental getter method: not currently part of the upstream
   * sdk's API */
  getResourceAttributes() {
    return this._resource.attributes;
  }
  shutdown() {
    const promises = [];
    if (this._tracerProvider) {
      promises.push(this._tracerProvider.shutdown());
    }
    return Promise.all(promises)
    // return void instead of the array from Promise.all
    .then(() => {});
  }
}

const VERSION = '0.8.1';

function configureHoneycombResource() {
  return new resources.Resource({
    'honeycomb.distro.version': VERSION,
    'honeycomb.distro.runtime_version': 'browser'
  });
}

const defaultConfig = {
  path: true,
  hash: true,
  hostname: true,
  referrer: true,
  url: false,
  search: false
};
function configureEntryPageResource(config) {
  if (config === false || !(window === null || window === void 0 ? void 0 : window.location)) {
    return new resources.Resource({});
  }
  const options = getOptions(config);
  const {
    href,
    pathname,
    search,
    hash,
    hostname
  } = window.location;
  const attributes = {
    'entry_page.url': optionalAttribute(options.url, href),
    'entry_page.path': optionalAttribute(options.path, pathname),
    'entry_page.search': optionalAttribute(options.search, search),
    'entry_page.hash': optionalAttribute(options.hash, hash),
    'entry_page.hostname': optionalAttribute(options.hostname, hostname),
    'entry_page.referrer': optionalAttribute(options.referrer, document.referrer)
  };
  return new resources.Resource(attributes);
}
function getOptions(config) {
  if (!config) {
    return defaultConfig;
  }
  return Object.assign(Object.assign({}, defaultConfig), config);
}
function optionalAttribute(shouldInclude, attribute) {
  if (!shouldInclude) {
    return undefined;
  }
  return attribute;
}

const computeScreenSize = screenWidth => {
  if (screenWidth <= 768) return 'small';else if (screenWidth > 768 && screenWidth <= 1024) return 'medium';else if (screenWidth > 1024) return 'large';
  return 'unknown';
};
const computeNetworkType = networkInformation => {
  var _a;
  return (_a = networkInformation === null || networkInformation === void 0 ? void 0 : networkInformation.effectiveType) !== null && _a !== void 0 ? _a : 'unknown';
};
const computeDeviceType = (detectedDeviceType, detectedBrowserName) => {
  // ua-parser-js doesn't fill in device type unless it's in the user agent directly
  // which means that desktops/laptops show up as undefined
  // https://github.com/faisalman/ua-parser-js/issues/182
  //
  // we're going to do this:
  // browser name & device type both undefined -> unknown
  // browser name defined & device type undefined -> desktop
  // device type defined -> use that
  if (!detectedDeviceType && !detectedBrowserName) {
    return 'unknown';
  }
  if (!detectedDeviceType) {
    return 'desktop';
  }
  return detectedDeviceType;
};
const computeDeviceProperties = userAgent => {
  const uaParser = new UAParser(userAgent);
  const {
    name: browserName,
    version: browserVersion
  } = uaParser.getBrowser();
  return {
    browserName: browserName !== null && browserName !== void 0 ? browserName : 'unknown',
    browserVersion: browserVersion !== null && browserVersion !== void 0 ? browserVersion : 'unknown',
    deviceType: computeDeviceType(uaParser.getDevice().type, browserName)
  };
};
function configureBrowserAttributesResource() {
  const {
    browserName,
    browserVersion,
    deviceType
  } = computeDeviceProperties(navigator.userAgent);
  return new resources.Resource({
    'user_agent.original': navigator.userAgent,
    //https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_tablet_or_desktop
    'browser.mobile': navigator.userAgent.includes('Mobi'),
    'browser.touch_screen_enabled': navigator.maxTouchPoints > 0,
    'browser.language': navigator.language,
    'browser.name': browserName,
    'browser.version': browserVersion,
    'device.type': deviceType,
    'network.effectiveType': computeNetworkType(navigator.connection),
    'screen.width': window.screen.width,
    'screen.height': window.screen.height,
    'screen.size': computeScreenSize(window.screen.width)
  });
}

/* Takes an array of resources and merges into one mega-resource */
function mergeResources(resources) {
  let mergedResources = validateResource(resources[0]);
  for (let i = 1; i < resources.length; i++) {
    if (!resources[i]) {
      continue;
    }
    const resource = validateResource(resources[i]);
    mergedResources = mergedResources.merge(resource);
  }
  return mergedResources;
}
function validateResource(resource) {
  if (resource instanceof resources.Resource) {
    return resource;
  }
  if (resource) {
    return new resources.Resource(resource);
  }
  return new resources.Resource({});
}

// Constants
const DEFAULT_API_ENDPOINT = 'https://api.honeycomb.io';
const TRACES_PATH = 'v1/traces';
const DEFAULT_TRACES_ENDPOINT = `${DEFAULT_API_ENDPOINT}/${TRACES_PATH}`;
const DEFAULT_SERVICE_NAME = 'unknown_service';
const DEFAULT_SAMPLE_RATE = 1;
/**
 * Default options for the Honeycomb Web SDK.
 */
const defaultOptions = {
  apiKey: '',
  tracesApiKey: '',
  endpoint: DEFAULT_TRACES_ENDPOINT,
  tracesEndpoint: DEFAULT_TRACES_ENDPOINT,
  serviceName: DEFAULT_SERVICE_NAME,
  debug: false,
  sampleRate: 1,
  skipOptionsValidation: false,
  localVisualizations: false,
  webVitalsInstrumentationConfig: {
    enabled: true
  }
};
const createHoneycombSDKLogMessage = message => `@honeycombio/opentelemetry-web: ${message}`;
const classicKeyRegex = /^[a-f0-9]*$/;
const ingestClassicKeyRegex = /^hc[a-z]ic_[a-z0-9]*$/;
/**
 * Determines whether the passed in apikey is classic or not.
 *
 * @param apikey the apikey
 * @returns a boolean to indicate if the apikey was a classic key
 */
function isClassic(apikey) {
  if (apikey == null || apikey.length === 0) {
    return false;
  } else if (apikey.length === 32) {
    return classicKeyRegex.test(apikey);
  } else if (apikey.length === 64) {
    return ingestClassicKeyRegex.test(apikey);
  }
  return false;
}
/**
 * Checks for and appends v1/traces to provided URL if missing when using an HTTP
 * based exporter protocol.
 *
 * @param url the base URL to append traces path to if missing
 * @returns the endpoint with traces path appended if missing
 */
function maybeAppendTracesPath(url) {
  if (url.endsWith(TRACES_PATH) || url.endsWith(`${TRACES_PATH}/`)) {
    return url;
  }
  return url.endsWith('/') ? url + TRACES_PATH : url + '/' + TRACES_PATH;
}
const getTracesEndpoint = options => {
  // use `tracesEndpoint` option unchanged if provided
  if (options === null || options === void 0 ? void 0 : options.tracesEndpoint) {
    return options.tracesEndpoint;
  }
  // use `endpoint` option if provided and append '/v1/traces' if not already appended
  if (options === null || options === void 0 ? void 0 : options.endpoint) {
    return maybeAppendTracesPath(options.endpoint);
  }
  return DEFAULT_TRACES_ENDPOINT;
};
const getTracesApiKey = options => {
  return (options === null || options === void 0 ? void 0 : options.tracesApiKey) || (options === null || options === void 0 ? void 0 : options.apiKey);
};
const getSampleRate = options => {
  if (
  // must be a whole positive integer
  typeof (options === null || options === void 0 ? void 0 : options.sampleRate) === 'number' && Number.isSafeInteger(options === null || options === void 0 ? void 0 : options.sampleRate) && (options === null || options === void 0 ? void 0 : options.sampleRate) >= 0) {
    return options === null || options === void 0 ? void 0 : options.sampleRate;
  }
  return DEFAULT_SAMPLE_RATE;
};

const MISSING_API_KEY_ERROR = createHoneycombSDKLogMessage('âŒ Missing API Key. Set `apiKey` in HoneycombOptions. Telemetry will not be exported.');
const MISSING_SERVICE_NAME_ERROR = createHoneycombSDKLogMessage(`âŒ Missing Service Name. Set \`serviceName\` in HoneycombOptions. Defaulting to '${defaultOptions.serviceName}'`);
const IGNORED_DATASET_ERROR = createHoneycombSDKLogMessage('ðŸ”• Dataset is ignored in favor of service name.');
const MISSING_DATASET_ERROR = createHoneycombSDKLogMessage('âŒ Missing dataset. Specify either HONEYCOMB_DATASET environment variable or dataset in the options parameter.');
const SKIPPING_OPTIONS_VALIDATION_MSG = createHoneycombSDKLogMessage('â­ï¸ Skipping options validation. To re-enable, set skipOptionsValidation option or HONEYCOMB_SKIP_OPTIONS_VALIDATION to false.');
const SAMPLER_OVERRIDE_WARNING = createHoneycombSDKLogMessage('ðŸ”¨ Default deterministic sampler has been overridden. Honeycomb requires a resource attribute called SampleRate to properly show weighted values. Non-deterministic sampleRate could lead to missing spans in Honeycomb. See our docs for more details. https://docs.honeycomb.io/getting-data-in/opentelemetry/node-distro/#sampling-without-the-honeycomb-sdk');
const MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage('ðŸ”• Disabling local visualizations - must have both service name and API key configured.');
const FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS = createHoneycombSDKLogMessage('ðŸ”• Failed to get proper auth response from Honeycomb. No local visualization available.');
const NO_EXPORTERS_DISABLED_DEFAULT = createHoneycombSDKLogMessage('ðŸ”• Default honeycomb exporter disabled but no exporters provided');
const validateOptionsWarnings = options => {
  var _a;
  const logLevel = (options === null || options === void 0 ? void 0 : options.logLevel) ? options.logLevel : api.DiagLogLevel.DEBUG;
  if (options === null || options === void 0 ? void 0 : options.skipOptionsValidation) {
    if (logLevel >= api.DiagLogLevel.DEBUG) {
      console.debug(SKIPPING_OPTIONS_VALIDATION_MSG);
    }
    return;
  }
  // warn if api key is missing
  if (!(options === null || options === void 0 ? void 0 : options.apiKey) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(MISSING_API_KEY_ERROR);
  }
  // warn if service name is missing
  if (!(options === null || options === void 0 ? void 0 : options.serviceName) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(MISSING_SERVICE_NAME_ERROR);
  }
  // warn if dataset is set while using an environment-aware key
  if ((options === null || options === void 0 ? void 0 : options.apiKey) && !isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && (options === null || options === void 0 ? void 0 : options.dataset) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(IGNORED_DATASET_ERROR);
  }
  // warn if dataset is missing if using classic key
  if ((options === null || options === void 0 ? void 0 : options.apiKey) && isClassic(options === null || options === void 0 ? void 0 : options.apiKey) && !(options === null || options === void 0 ? void 0 : options.dataset) && logLevel >= api.DiagLogLevel.WARN) {
    console.warn(MISSING_DATASET_ERROR);
  }
  // warn if custom sampler provided
  if ((options === null || options === void 0 ? void 0 : options.sampler) && logLevel >= api.DiagLogLevel.DEBUG) {
    console.debug(SAMPLER_OVERRIDE_WARNING);
  }
  // warn if no exporter will be set
  if ((options === null || options === void 0 ? void 0 : options.disableDefaultTraceExporter) === true && !(options === null || options === void 0 ? void 0 : options.traceExporter) && !((_a = options === null || options === void 0 ? void 0 : options.traceExporters) === null || _a === void 0 ? void 0 : _a.length)) {
    console.warn(NO_EXPORTERS_DISABLED_DEFAULT);
  }
  return options;
};

/**
 * Configures the Honeycomb Web SDK to log debug information to the console.
 * Enables the DiagConsoleLogger and sets the log level to DEBUG.
 * Logs the provided Honeycomb options to the console, as well as defaults.
 *
 * @param options the provided Honeycomb options
 */
function configureDebug(options) {
  if (!(options === null || options === void 0 ? void 0 : options.debug)) {
    return;
  }
  api.diag.setLogger(new api.DiagConsoleLogger(), api.DiagLogLevel.DEBUG);
  api.diag.debug(createHoneycombSDKLogMessage('ðŸ Honeycomb Web SDK Debug Mode Enabled ðŸ'));
  // traces endpoint must be computed from provided options
  const tracesEndpoint = getTracesEndpoint(options);
  const currentOptions = Object.assign(Object.assign(Object.assign({}, defaultOptions), options), {
    tracesEndpoint
  });
  debugTracesApiKey(currentOptions);
  debugServiceName(currentOptions);
  debugTracesEndpoint(currentOptions);
  debugSampleRate(currentOptions);
}
function debugTracesApiKey(options) {
  const tracesApiKey = getTracesApiKey(options) || '';
  if (!tracesApiKey) {
    api.diag.debug(MISSING_API_KEY_ERROR);
    return;
  }
  api.diag.debug(createHoneycombSDKLogMessage(`API Key configured for traces: '${tracesApiKey}'`));
}
function debugServiceName(options) {
  const serviceName = options.serviceName || defaultOptions.serviceName;
  if (serviceName === defaultOptions.serviceName) {
    api.diag.debug(MISSING_SERVICE_NAME_ERROR);
    return;
  }
  api.diag.debug(`@honeycombio/opentelemetry-web: Service Name configured for traces: '${serviceName}'`);
}
function debugTracesEndpoint(options) {
  const tracesEndpoint = getTracesEndpoint(options);
  if (!tracesEndpoint) {
    api.diag.debug(createHoneycombSDKLogMessage('No endpoint configured for traces'));
    return;
  }
  api.diag.debug(createHoneycombSDKLogMessage(`Endpoint configured for traces: '${tracesEndpoint}'`));
}
function debugSampleRate(options) {
  const sampleRate = getSampleRate(options);
  if (!sampleRate) {
    // this should never happen, but guard just in case?
    api.diag.debug('No sampler configured for traces');
    return;
  }
  api.diag.debug(createHoneycombSDKLogMessage(`Sample Rate configured for traces: '${sampleRate}'`));
}

/**
 * A {@link SpanProcessor} that reads entries stored in {@link Baggage}
 * from the parent context and adds the baggage entries' keys and values
 * to the span as attributes on span start.
 *
 * Keys and values added to Baggage will appear on subsequent child
 * spans for a trace within this service *and* be propagated to external
 * services in accordance with any configured propagation formats
 * configured. If the external services also have a Baggage span
 * processor, the keys and values will appear in those child spans as
 * well.
 *
 * âš  Warning âš ï¸
 *
 * Do not put sensitive information in Baggage.
 *
 * To repeat: a consequence of adding data to Baggage is that the keys and
 * values will appear in all outgoing HTTP headers from the application.
 */
class BaggageSpanProcessor {
  constructor() {}
  onStart(span, parentContext) {
    var _a, _b;
    ((_b = (_a = api.propagation.getBaggage(parentContext)) === null || _a === void 0 ? void 0 : _a.getAllEntries()) !== null && _b !== void 0 ? _b : []).forEach(entry => {
      span.setAttribute(entry[0], entry[1].value);
      api.diag.debug(`@honeycombio/opentelemetry-web: ðŸš¨ Baggage in all outgoing headers: ${entry[0]}=${entry[1].value} `);
    });
  }
  onEnd() {}
  forceFlush() {
    return Promise.resolve();
  }
  shutdown() {
    return Promise.resolve();
  }
}

/**
 * A {@link SpanProcessor} that adds browser specific attributes to each span
 * that might change over the course of a session.
 * Static attributes (e.g. User Agent) are added to the Resource.
 */
class BrowserAttributesSpanProcessor {
  constructor() {}
  onStart(span) {
    const {
      href,
      pathname,
      search,
      hash,
      hostname
    } = window.location;
    span.setAttributes({
      'browser.width': window.innerWidth,
      'browser.height': window.innerHeight,
      'page.hash': hash,
      'page.url': href,
      'page.route': pathname,
      'page.hostname': hostname,
      'page.search': search,
      'url.path': pathname
    });
  }
  onEnd() {}
  forceFlush() {
    return Promise.resolve();
  }
  shutdown() {
    return Promise.resolve();
  }
}

const TEAM_HEADER_KEY = 'x-honeycomb-team';
const DATASET_HEADER_KEY = 'x-honeycomb-dataset';
/**
 * Builds and returns an OTLP Traces exporter that sends data over http/json
 * @param options The {@link HoneycombOptions} used to configure the exporter
 * @returns a {@link SpanExporter} configured to send telemetry to Honeycomb over http/json
 */
function configureHoneycombHttpJsonTraceExporter(options) {
  const apiKey = getTracesApiKey(options);
  return new exporterTraceOtlpHttp.OTLPTraceExporter({
    url: getTracesEndpoint(options),
    headers: Object.assign({
      [TEAM_HEADER_KEY]: apiKey,
      [DATASET_HEADER_KEY]: isClassic(apiKey) ? options === null || options === void 0 ? void 0 : options.dataset : undefined
    }, options === null || options === void 0 ? void 0 : options.headers)
  });
}

/**
 * Builds and returns a new {@link SpanExporter} that wraps the provided array
 * of {@link SpanExporter}s
 *
 * @param exporters the exporters to wrap with the composite exporter
 * @returns the configured {@link SpanExporter} instance
 */
function configureCompositeExporter(exporters) {
  return new CompositeSpanExporter(exporters);
}
/**
 * A custom SpanExporter that wraps a number of other exporters and calls export and shutdown
 * for each.
 */
class CompositeSpanExporter {
  constructor(exporters) {
    this._exporters = exporters;
  }
  export(spans, resultCallback) {
    this._exporters.forEach(exporter => exporter.export(spans, resultCallback));
    resultCallback({
      code: core.ExportResultCode.SUCCESS
    });
  }
  async shutdown() {
    const results = [];
    this._exporters.forEach(exporter => results.push(exporter.shutdown()));
    await Promise.all(results);
  }
}

/**
 * Builds and returns a {@link SpanExporter} that logs Honeycomb URLs for completed traces
 *
 * @remark This is not for production use.
 * @param options The {@link HoneycombOptions} used to configure the exporter
 * @returns the configured {@link ConsoleTraceLinkExporter} instance
 */
function configureConsoleTraceLinkExporter(options) {
  const apiKey = getTracesApiKey(options);
  return new ConsoleTraceLinkExporter(options === null || options === void 0 ? void 0 : options.serviceName, apiKey, options === null || options === void 0 ? void 0 : options.logLevel);
}
/**
 * A custom {@link SpanExporter} that logs Honeycomb URLs for completed traces.
 *
 * @remark This is not for production use.
 */
class ConsoleTraceLinkExporter {
  constructor(serviceName, apikey, logLevel) {
    this._traceUrl = '';
    this._logLevel = api.DiagLogLevel.DEBUG;
    if (logLevel) {
      this._logLevel = logLevel;
    }
    if (!serviceName || !apikey) {
      if (this._logLevel >= api.DiagLogLevel.DEBUG) {
        console.debug(MISSING_FIELDS_FOR_LOCAL_VISUALIZATIONS);
      }
      return;
    }
    const options = {
      headers: {
        'x-honeycomb-team': apikey
      }
    };
    fetch('https://api.honeycomb.io/1/auth', options).then(resp => {
      if (resp.ok) {
        return resp.json();
      }
      throw new Error();
    }).then(data => {
      var _a, _b, _c;
      const respData = data;
      if ((_a = respData.team) === null || _a === void 0 ? void 0 : _a.slug) {
        this._traceUrl = buildTraceUrl(apikey, serviceName, (_b = respData.team) === null || _b === void 0 ? void 0 : _b.slug, (_c = respData.environment) === null || _c === void 0 ? void 0 : _c.slug);
      } else {
        throw new Error();
      }
    }).catch(() => {
      if (this._logLevel >= api.DiagLogLevel.INFO) {
        console.log(FAILED_AUTH_FOR_LOCAL_VISUALIZATIONS);
      }
    });
  }
  export(spans, resultCallback) {
    if (this._traceUrl) {
      spans.forEach(span => {
        // only log root spans (ones without a parent span)
        if (!span.parentSpanId && this._logLevel >= api.DiagLogLevel.INFO) {
          console.log(createHoneycombSDKLogMessage(`Honeycomb link: ${this._traceUrl}=${span.spanContext().traceId}`));
        }
      });
    }
    resultCallback({
      code: core.ExportResultCode.SUCCESS
    });
  }
  shutdown() {
    return Promise.resolve();
  }
}
/**
 * Builds and returns a URL that is used to log when a trace is completed in the {@link ConsoleTraceLinkExporter}.
 *
 * @param apikey the Honeycomb API key used to retrieve the Honeycomb team and environment
 * @param serviceName the Honeycomb service name (or classic dataset) where data is stored
 * @param team the Honeycomb team
 * @param environment the Honeycomb environment
 * @returns
 */
function buildTraceUrl(apikey, serviceName, team, environment) {
  let url = `https://ui.honeycomb.io/${team}`;
  if (!isClassic(apikey) && environment) {
    url += `/environments/${environment}`;
  }
  url += `/datasets/${serviceName}/trace?trace_id`;
  return url;
}

/**
 * Builds and returns Span Processor that combines the BatchSpanProcessor, BrowserSpanProcessor,
 * BaggageSpanProcessor, and optionally a user provided Span Processor.
 * @param options The {@link HoneycombOptions}
 * @returns a {@link CompositeSpanProcessor}
 */
const configureSpanProcessors = options => {
  const honeycombSpanProcessor = new CompositeSpanProcessor();
  const honeycombTraceExporters = [];
  if (options === null || options === void 0 ? void 0 : options.localVisualizations) {
    honeycombTraceExporters.push(configureConsoleTraceLinkExporter(options));
  }
  // if there is a user-provided exporter, add to the composite exporter
  if (options === null || options === void 0 ? void 0 : options.traceExporter) {
    honeycombTraceExporters.push(options === null || options === void 0 ? void 0 : options.traceExporter);
  }
  // if there is an array of user-provided exporters, add them to the composite exporter
  // This will override the default honeycomb trace exporter.
  if (options === null || options === void 0 ? void 0 : options.traceExporters) {
    honeycombTraceExporters.push(...options.traceExporters);
  }
  // Disable this if a configuration option is present
  if ((options === null || options === void 0 ? void 0 : options.disableDefaultTraceExporter) !== true) {
    honeycombTraceExporters.unshift(configureHoneycombHttpJsonTraceExporter(options));
  }
  // We have to configure the exporter here because the way the base SDK is setup
  // does not allow having both a `spanProcessor` and `traceExporter` configured.
  honeycombSpanProcessor.addProcessor(new sdkTraceBase.BatchSpanProcessor(configureCompositeExporter([...honeycombTraceExporters])));
  // we always want to add the baggage span processor
  honeycombSpanProcessor.addProcessor(new BaggageSpanProcessor());
  // we always want to add the browser attrs span processor
  honeycombSpanProcessor.addProcessor(new BrowserAttributesSpanProcessor());
  // if there is a user provided span processor, add it to the composite span processor
  if (options === null || options === void 0 ? void 0 : options.spanProcessor) {
    honeycombSpanProcessor.addProcessor(options === null || options === void 0 ? void 0 : options.spanProcessor);
  }
  // if there is an array of spanProcessors provided, add them to the composite span processor
  if (options === null || options === void 0 ? void 0 : options.spanProcessors) {
    options.spanProcessors.forEach(processor => {
      honeycombSpanProcessor.addProcessor(processor);
    });
  }
  return honeycombSpanProcessor;
};
/**
 * A {@link SpanProcessor} that combines multiple span processors into a single
 * span processor that can be passed into the SDKs `spanProcessor` option.
 */
class CompositeSpanProcessor {
  constructor() {
    this.spanProcessors = [];
  }
  addProcessor(processor) {
    this.spanProcessors.push(processor);
  }
  getSpanProcessors() {
    return this.spanProcessors;
  }
  onStart(span, parentContext) {
    this.spanProcessors.forEach(processor => {
      processor.onStart(span, parentContext);
    });
  }
  onEnd(span) {
    this.spanProcessors.forEach(processor => {
      processor.onEnd(span);
    });
  }
  forceFlush() {
    return Promise.all(this.spanProcessors.map(processor => processor.forceFlush())).then(() => {});
  }
  shutdown() {
    return Promise.all(this.spanProcessors.map(processor => processor.forceFlush())).then(() => {});
  }
}

/**
 * Builds and returns a Deterministic Sampler that uses the provided sample rate to
 * configure the inner sampler.
 * @param options The {@link HoneycombOptions}
 * @returns a {@link DeterministicSampler}
 */
const configureDeterministicSampler = options => {
  const sampleRate = getSampleRate(options);
  return new DeterministicSampler(sampleRate);
};
/**
 * A {@link Sampler} that uses a deterministic sample rate to configure the sampler.
 */
class DeterministicSampler {
  constructor(sampleRate) {
    this._sampleRate = sampleRate;
    switch (sampleRate) {
      // sample rate of 0 means send nothing
      case 0:
        this._sampler = new sdkTraceBase.AlwaysOffSampler();
        break;
      // sample rate of 1 is default, send everything
      case 1:
        this._sampler = new sdkTraceBase.AlwaysOnSampler();
        break;
      default:
        {
          const ratio = 1.0 / sampleRate;
          this._sampler = new sdkTraceBase.TraceIdRatioBasedSampler(ratio);
          break;
        }
    }
  }
  shouldSample(context, traceId, spanName, spanKind, attributes, links) {
    const result = this._sampler.shouldSample(context, traceId, spanName, spanKind, attributes, links);
    return Object.assign(Object.assign({}, result), {
      attributes: Object.assign(Object.assign({}, result.attributes), {
        SampleRate: this._sampleRate
      })
    });
  }
  toString() {
    return `DeterministicSampler(${this._sampler.toString()})`;
  }
}

var t,
  e,
  n = function () {
    var t = self.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0];
    if (t && t.responseStart > 0 && t.responseStart < performance.now()) return t;
  },
  r = function (t) {
    if ("loading" === document.readyState) return "loading";
    var e = n();
    if (e) {
      if (t < e.domInteractive) return "loading";
      if (0 === e.domContentLoadedEventStart || t < e.domContentLoadedEventStart) return "dom-interactive";
      if (0 === e.domComplete || t < e.domComplete) return "dom-content-loaded";
    }
    return "complete";
  },
  i = function (t) {
    var e = t.nodeName;
    return 1 === t.nodeType ? e.toLowerCase() : e.toUpperCase().replace(/^#/, "");
  },
  a = function (t, e) {
    var n = "";
    try {
      for (; t && 9 !== t.nodeType;) {
        var r = t,
          a = r.id ? "#" + r.id : i(r) + (r.classList && r.classList.value && r.classList.value.trim() && r.classList.value.trim().length ? "." + r.classList.value.trim().replace(/\s+/g, ".") : "");
        if (n.length + a.length > (e || 100) - 1) return n || a;
        if (n = n ? a + ">" + n : a, r.id) break;
        t = r.parentNode;
      }
    } catch (t) {}
    return n;
  },
  o = -1,
  c = function () {
    return o;
  },
  u = function (t) {
    addEventListener("pageshow", function (e) {
      e.persisted && (o = e.timeStamp, t(e));
    }, !0);
  },
  s = function () {
    var t = n();
    return t && t.activationStart || 0;
  },
  f = function (t, e) {
    var r = n(),
      i = "navigate";
    c() >= 0 ? i = "back-forward-cache" : r && (document.prerendering || s() > 0 ? i = "prerender" : document.wasDiscarded ? i = "restore" : r.type && (i = r.type.replace(/_/g, "-")));
    return {
      name: t,
      value: void 0 === e ? -1 : e,
      rating: "good",
      delta: 0,
      entries: [],
      id: "v4-".concat(Date.now(), "-").concat(Math.floor(8999999999999 * Math.random()) + 1e12),
      navigationType: i
    };
  },
  d = function (t, e, n) {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(t)) {
        var r = new PerformanceObserver(function (t) {
          Promise.resolve().then(function () {
            e(t.getEntries());
          });
        });
        return r.observe(Object.assign({
          type: t,
          buffered: !0
        }, n || {})), r;
      }
    } catch (t) {}
  },
  l = function (t, e, n, r) {
    var i, a;
    return function (o) {
      e.value >= 0 && (o || r) && ((a = e.value - (i || 0)) || void 0 === i) && (i = e.value, e.delta = a, e.rating = function (t, e) {
        return t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good";
      }(e.value, n), t(e));
    };
  },
  m = function (t) {
    requestAnimationFrame(function () {
      return requestAnimationFrame(function () {
        return t();
      });
    });
  },
  p = function (t) {
    document.addEventListener("visibilitychange", function () {
      "hidden" === document.visibilityState && t();
    });
  },
  v = function (t) {
    var e = !1;
    return function () {
      e || (t(), e = !0);
    };
  },
  g = -1,
  h = function () {
    return "hidden" !== document.visibilityState || document.prerendering ? 1 / 0 : 0;
  },
  T = function (t) {
    "hidden" === document.visibilityState && g > -1 && (g = "visibilitychange" === t.type ? t.timeStamp : 0, E());
  },
  y = function () {
    addEventListener("visibilitychange", T, !0), addEventListener("prerenderingchange", T, !0);
  },
  E = function () {
    removeEventListener("visibilitychange", T, !0), removeEventListener("prerenderingchange", T, !0);
  },
  S = function () {
    return g < 0 && (g = h(), y(), u(function () {
      setTimeout(function () {
        g = h(), y();
      }, 0);
    })), {
      get firstHiddenTime() {
        return g;
      }
    };
  },
  b = function (t) {
    document.prerendering ? addEventListener("prerenderingchange", function () {
      return t();
    }, !0) : t();
  },
  L = [1800, 3e3],
  C = function (t, e) {
    e = e || {}, b(function () {
      var n,
        r = S(),
        i = f("FCP"),
        a = d("paint", function (t) {
          t.forEach(function (t) {
            "first-contentful-paint" === t.name && (a.disconnect(), t.startTime < r.firstHiddenTime && (i.value = Math.max(t.startTime - s(), 0), i.entries.push(t), n(!0)));
          });
        });
      a && (n = l(t, i, L, e.reportAllChanges), u(function (r) {
        i = f("FCP"), n = l(t, i, L, e.reportAllChanges), m(function () {
          i.value = performance.now() - r.timeStamp, n(!0);
        });
      }));
    });
  },
  M = [.1, .25],
  D = function (t, e) {
    !function (t, e) {
      e = e || {}, C(v(function () {
        var n,
          r = f("CLS", 0),
          i = 0,
          a = [],
          o = function (t) {
            t.forEach(function (t) {
              if (!t.hadRecentInput) {
                var e = a[0],
                  n = a[a.length - 1];
                i && t.startTime - n.startTime < 1e3 && t.startTime - e.startTime < 5e3 ? (i += t.value, a.push(t)) : (i = t.value, a = [t]);
              }
            }), i > r.value && (r.value = i, r.entries = a, n());
          },
          c = d("layout-shift", o);
        c && (n = l(t, r, M, e.reportAllChanges), p(function () {
          o(c.takeRecords()), n(!0);
        }), u(function () {
          i = 0, r = f("CLS", 0), n = l(t, r, M, e.reportAllChanges), m(function () {
            return n();
          });
        }), setTimeout(n, 0));
      }));
    }(function (e) {
      var n = function (t) {
        var e,
          n = {};
        if (t.entries.length) {
          var i = t.entries.reduce(function (t, e) {
            return t && t.value > e.value ? t : e;
          });
          if (i && i.sources && i.sources.length) {
            var o = (e = i.sources).find(function (t) {
              return t.node && 1 === t.node.nodeType;
            }) || e[0];
            o && (n = {
              largestShiftTarget: a(o.node),
              largestShiftTime: i.startTime,
              largestShiftValue: i.value,
              largestShiftSource: o,
              largestShiftEntry: i,
              loadState: r(i.startTime)
            });
          }
        }
        return Object.assign(t, {
          attribution: n
        });
      }(e);
      t(n);
    }, e);
  },
  w = function (t, e) {
    C(function (e) {
      var i = function (t) {
        var e = {
          timeToFirstByte: 0,
          firstByteToFCP: t.value,
          loadState: r(c())
        };
        if (t.entries.length) {
          var i = n(),
            a = t.entries[t.entries.length - 1];
          if (i) {
            var o = i.activationStart || 0,
              u = Math.max(0, i.responseStart - o);
            e = {
              timeToFirstByte: u,
              firstByteToFCP: t.value - u,
              loadState: r(t.entries[0].startTime),
              navigationEntry: i,
              fcpEntry: a
            };
          }
        }
        return Object.assign(t, {
          attribution: e
        });
      }(e);
      t(i);
    }, e);
  },
  x = 0,
  I = 1 / 0,
  k = 0,
  A = function (t) {
    t.forEach(function (t) {
      t.interactionId && (I = Math.min(I, t.interactionId), k = Math.max(k, t.interactionId), x = k ? (k - I) / 7 + 1 : 0);
    });
  },
  F = function () {
    return t ? x : performance.interactionCount || 0;
  },
  P = function () {
    "interactionCount" in performance || t || (t = d("event", A, {
      type: "event",
      buffered: !0,
      durationThreshold: 0
    }));
  },
  B = [],
  O = new Map(),
  R = 0,
  j = function () {
    var t = Math.min(B.length - 1, Math.floor((F() - R) / 50));
    return B[t];
  },
  q = [],
  H = function (t) {
    if (q.forEach(function (e) {
      return e(t);
    }), t.interactionId || "first-input" === t.entryType) {
      var e = B[B.length - 1],
        n = O.get(t.interactionId);
      if (n || B.length < 10 || t.duration > e.latency) {
        if (n) t.duration > n.latency ? (n.entries = [t], n.latency = t.duration) : t.duration === n.latency && t.startTime === n.entries[0].startTime && n.entries.push(t);else {
          var r = {
            id: t.interactionId,
            latency: t.duration,
            entries: [t]
          };
          O.set(r.id, r), B.push(r);
        }
        B.sort(function (t, e) {
          return e.latency - t.latency;
        }), B.length > 10 && B.splice(10).forEach(function (t) {
          return O.delete(t.id);
        });
      }
    }
  },
  N = function (t) {
    var e = self.requestIdleCallback || self.setTimeout,
      n = -1;
    return t = v(t), "hidden" === document.visibilityState ? t() : (n = e(t), p(t)), n;
  },
  W = [200, 500],
  z = function (t, e) {
    "PerformanceEventTiming" in self && "interactionId" in PerformanceEventTiming.prototype && (e = e || {}, b(function () {
      var n;
      P();
      var r,
        i = f("INP"),
        a = function (t) {
          N(function () {
            t.forEach(H);
            var e = j();
            e && e.latency !== i.value && (i.value = e.latency, i.entries = e.entries, r());
          });
        },
        o = d("event", a, {
          durationThreshold: null !== (n = e.durationThreshold) && void 0 !== n ? n : 40
        });
      r = l(t, i, W, e.reportAllChanges), o && (o.observe({
        type: "first-input",
        buffered: !0
      }), p(function () {
        a(o.takeRecords()), r(!0);
      }), u(function () {
        R = F(), B.length = 0, O.clear(), i = f("INP"), r = l(t, i, W, e.reportAllChanges);
      }));
    }));
  },
  U = [],
  V = [],
  _ = 0,
  G = new WeakMap(),
  J = new Map(),
  K = -1,
  Q = function (t) {
    U = U.concat(t), X();
  },
  X = function () {
    K < 0 && (K = N(Y));
  },
  Y = function () {
    J.size > 10 && J.forEach(function (t, e) {
      O.has(e) || J.delete(e);
    });
    var t = B.map(function (t) {
        return G.get(t.entries[0]);
      }),
      e = V.length - 50;
    V = V.filter(function (n, r) {
      return r >= e || t.includes(n);
    });
    for (var n = new Set(), r = 0; r < V.length; r++) {
      var i = V[r];
      nt(i.startTime, i.processingEnd).forEach(function (t) {
        n.add(t);
      });
    }
    var a = U.length - 1 - 50;
    U = U.filter(function (t, e) {
      return t.startTime > _ && e > a || n.has(t);
    }), K = -1;
  };
q.push(function (t) {
  t.interactionId && t.target && !J.has(t.interactionId) && J.set(t.interactionId, t.target);
}, function (t) {
  var e,
    n = t.startTime + t.duration;
  _ = Math.max(_, t.processingEnd);
  for (var r = V.length - 1; r >= 0; r--) {
    var i = V[r];
    if (Math.abs(n - i.renderTime) <= 8) {
      (e = i).startTime = Math.min(t.startTime, e.startTime), e.processingStart = Math.min(t.processingStart, e.processingStart), e.processingEnd = Math.max(t.processingEnd, e.processingEnd), e.entries.push(t);
      break;
    }
  }
  e || (e = {
    startTime: t.startTime,
    processingStart: t.processingStart,
    processingEnd: t.processingEnd,
    renderTime: n,
    entries: [t]
  }, V.push(e)), (t.interactionId || "first-input" === t.entryType) && G.set(t, e), X();
});
var Z,
  $,
  tt,
  et,
  nt = function (t, e) {
    for (var n, r = [], i = 0; n = U[i]; i++) if (!(n.startTime + n.duration < t)) {
      if (n.startTime > e) break;
      r.push(n);
    }
    return r;
  },
  rt = function (t, n) {
    e || (e = d("long-animation-frame", Q)), z(function (e) {
      var n = function (t) {
        var e = t.entries[0],
          n = G.get(e),
          i = e.processingStart,
          o = n.processingEnd,
          c = n.entries.sort(function (t, e) {
            return t.processingStart - e.processingStart;
          }),
          u = nt(e.startTime, o),
          s = t.entries.find(function (t) {
            return t.target;
          }),
          f = s && s.target || J.get(e.interactionId),
          d = [e.startTime + e.duration, o].concat(u.map(function (t) {
            return t.startTime + t.duration;
          })),
          l = Math.max.apply(Math, d),
          m = {
            interactionTarget: a(f),
            interactionTargetElement: f,
            interactionType: e.name.startsWith("key") ? "keyboard" : "pointer",
            interactionTime: e.startTime,
            nextPaintTime: l,
            processedEventEntries: c,
            longAnimationFrameEntries: u,
            inputDelay: i - e.startTime,
            processingDuration: o - i,
            presentationDelay: Math.max(l - o, 0),
            loadState: r(e.startTime)
          };
        return Object.assign(t, {
          attribution: m
        });
      }(e);
      t(n);
    }, n);
  },
  it = [2500, 4e3],
  at = {},
  ot = function (t, e) {
    !function (t, e) {
      e = e || {}, b(function () {
        var n,
          r = S(),
          i = f("LCP"),
          a = function (t) {
            e.reportAllChanges || (t = t.slice(-1)), t.forEach(function (t) {
              t.startTime < r.firstHiddenTime && (i.value = Math.max(t.startTime - s(), 0), i.entries = [t], n());
            });
          },
          o = d("largest-contentful-paint", a);
        if (o) {
          n = l(t, i, it, e.reportAllChanges);
          var c = v(function () {
            at[i.id] || (a(o.takeRecords()), o.disconnect(), at[i.id] = !0, n(!0));
          });
          ["keydown", "click"].forEach(function (t) {
            addEventListener(t, function () {
              return N(c);
            }, !0);
          }), p(c), u(function (r) {
            i = f("LCP"), n = l(t, i, it, e.reportAllChanges), m(function () {
              i.value = performance.now() - r.timeStamp, at[i.id] = !0, n(!0);
            });
          });
        }
      });
    }(function (e) {
      var r = function (t) {
        var e = {
          timeToFirstByte: 0,
          resourceLoadDelay: 0,
          resourceLoadDuration: 0,
          elementRenderDelay: t.value
        };
        if (t.entries.length) {
          var r = n();
          if (r) {
            var i = r.activationStart || 0,
              o = t.entries[t.entries.length - 1],
              c = o.url && performance.getEntriesByType("resource").filter(function (t) {
                return t.name === o.url;
              })[0],
              u = Math.max(0, r.responseStart - i),
              s = Math.max(u, c ? (c.requestStart || c.startTime) - i : 0),
              f = Math.max(s, c ? c.responseEnd - i : 0),
              d = Math.max(f, o.startTime - i);
            e = {
              element: a(o.element),
              timeToFirstByte: u,
              resourceLoadDelay: s - u,
              resourceLoadDuration: f - s,
              elementRenderDelay: d - f,
              navigationEntry: r,
              lcpEntry: o
            }, o.url && (e.url = o.url), c && (e.lcpResourceEntry = c);
          }
        }
        return Object.assign(t, {
          attribution: e
        });
      }(e);
      t(r);
    }, e);
  },
  ct = [800, 1800],
  ut = function t(e) {
    document.prerendering ? b(function () {
      return t(e);
    }) : "complete" !== document.readyState ? addEventListener("load", function () {
      return t(e);
    }, !0) : setTimeout(e, 0);
  },
  st = function (t, e) {
    e = e || {};
    var r = f("TTFB"),
      i = l(t, r, ct, e.reportAllChanges);
    ut(function () {
      var a = n();
      a && (r.value = Math.max(a.responseStart - s(), 0), r.entries = [a], i(!0), u(function () {
        r = f("TTFB", 0), (i = l(t, r, ct, e.reportAllChanges))(!0);
      }));
    });
  },
  ft = function (t, e) {
    st(function (e) {
      var n = function (t) {
        var e = {
          waitingDuration: 0,
          cacheDuration: 0,
          dnsDuration: 0,
          connectionDuration: 0,
          requestDuration: 0
        };
        if (t.entries.length) {
          var n = t.entries[0],
            r = n.activationStart || 0,
            i = Math.max((n.workerStart || n.fetchStart) - r, 0),
            a = Math.max(n.domainLookupStart - r, 0),
            o = Math.max(n.connectStart - r, 0),
            c = Math.max(n.connectEnd - r, 0);
          e = {
            waitingDuration: i,
            cacheDuration: a - i,
            dnsDuration: o - a,
            connectionDuration: c - o,
            requestDuration: t.value - c,
            navigationEntry: n
          };
        }
        return Object.assign(t, {
          attribution: e
        });
      }(e);
      t(n);
    }, e);
  },
  dt = {
    passive: !0,
    capture: !0
  },
  lt = new Date(),
  mt = function (t, e) {
    Z || (Z = e, $ = t, tt = new Date(), gt(removeEventListener), pt());
  },
  pt = function () {
    if ($ >= 0 && $ < tt - lt) {
      var t = {
        entryType: "first-input",
        name: Z.type,
        target: Z.target,
        cancelable: Z.cancelable,
        startTime: Z.timeStamp,
        processingStart: Z.timeStamp + $
      };
      et.forEach(function (e) {
        e(t);
      }), et = [];
    }
  },
  vt = function (t) {
    if (t.cancelable) {
      var e = (t.timeStamp > 1e12 ? new Date() : performance.now()) - t.timeStamp;
      "pointerdown" == t.type ? function (t, e) {
        var n = function () {
            mt(t, e), i();
          },
          r = function () {
            i();
          },
          i = function () {
            removeEventListener("pointerup", n, dt), removeEventListener("pointercancel", r, dt);
          };
        addEventListener("pointerup", n, dt), addEventListener("pointercancel", r, dt);
      }(e, t) : mt(e, t);
    }
  },
  gt = function (t) {
    ["mousedown", "keydown", "touchstart", "pointerdown"].forEach(function (e) {
      return t(e, vt, dt);
    });
  },
  ht = [100, 300],
  Tt = function (t, e) {
    e = e || {}, b(function () {
      var n,
        r = S(),
        i = f("FID"),
        a = function (t) {
          t.startTime < r.firstHiddenTime && (i.value = t.processingStart - t.startTime, i.entries.push(t), n(!0));
        },
        o = function (t) {
          t.forEach(a);
        },
        c = d("first-input", o);
      n = l(t, i, ht, e.reportAllChanges), c && (p(v(function () {
        o(c.takeRecords()), c.disconnect();
      })), u(function () {
        var r;
        i = f("FID"), n = l(t, i, ht, e.reportAllChanges), et = [], $ = -1, Z = null, gt(addEventListener), r = a, et.push(r), pt();
      }));
    });
  },
  yt = function (t, e) {
    Tt(function (e) {
      var n = function (t) {
        var e = t.entries[0],
          n = {
            eventTarget: a(e.target),
            eventType: e.name,
            eventTime: e.startTime,
            eventEntry: e,
            loadState: r(e.startTime)
          };
        return Object.assign(t, {
          attribution: n
        });
      }(e);
      t(n);
    }, e);
  };

// To avoid importing InstrumentationAbstract from:
// import { InstrumentationAbstract } from '@opentelemetry/instrumentation/build/src/instrumentation';
// When this is exposed we can import from there.
class InstrumentationAbstract {
  constructor(instrumentationName, instrumentationVersion, config = {}) {
    this.instrumentationName = instrumentationName;
    this.instrumentationVersion = instrumentationVersion;
    /* Api to wrap instrumented method */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._wrap = shimmer__namespace.wrap;
    /* Api to unwrap instrumented methods */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._unwrap = shimmer__namespace.unwrap;
    /* Api to mass wrap instrumented method */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._massWrap = shimmer__namespace.massWrap;
    /* Api to mass unwrap instrumented methods */
    // eslint-disable-next-line @typescript-eslint/unbound-method
    this._massUnwrap = shimmer__namespace.massUnwrap;
    this._config = Object.assign({
      enabled: true
    }, config);
    this._diag = api.diag.createComponentLogger({
      namespace: instrumentationName
    });
    this._tracer = api.trace.getTracer(instrumentationName, instrumentationVersion);
    this._meter = api.metrics.getMeter(instrumentationName, instrumentationVersion);
    this._updateMetricInstruments();
  }
  /* Returns meter */
  get meter() {
    return this._meter;
  }
  /**
   * Sets MeterProvider to this plugin
   * @param meterProvider
   */
  setMeterProvider(meterProvider) {
    this._meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);
    this._updateMetricInstruments();
  }
  /**
   * Sets the new metric instruments with the current Meter.
   */
  _updateMetricInstruments() {
    return;
  }
  /* Returns InstrumentationConfig */
  getConfig() {
    return this._config;
  }
  /**
   * Sets InstrumentationConfig to this plugin
   * @param InstrumentationConfig
   */
  setConfig(config = {}) {
    this._config = Object.assign({}, config);
  }
  /**
   * Sets TraceProvider to this plugin
   * @param tracerProvider
   */
  setTracerProvider(tracerProvider) {
    this._tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);
  }
  /* Returns tracer */
  get tracer() {
    return this._tracer;
  }
}
/**
 * Web vitals auto-instrumentation, sends spans automatically for CLS, LCP, INP, FCP, FID, TTFB.
 * Defaults to sending spans for CLS, LCP, INP, FCP and TTFB.
 * @param config The {@link WebVitalsInstrumentationConfig }
 */
class WebVitalsInstrumentation extends InstrumentationAbstract {
  constructor({
    enabled = true,
    vitalsToTrack = ['CLS', 'LCP', 'INP'],
    lcp,
    cls,
    inp,
    fid,
    fcp,
    ttfb
  } = {}) {
    const config = {
      enabled,
      vitalsToTrack,
      lcp,
      cls,
      inp,
      fid,
      fcp,
      ttfb
    };
    super('@honeycombio/instrumentation-web-vitals', VERSION, config);
    this.onReportCLS = (cls, clsOpts = {}) => {
      const {
        applyCustomAttributes
      } = clsOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = cls;
      const {
        largestShiftTarget,
        largestShiftTime,
        largestShiftValue,
        loadState,
        largestShiftEntry
      } = attribution;
      const attrPrefix = this.getAttrPrefix(name);
      const span = this.tracer.startSpan(name);
      span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(cls)), {
        [`${attrPrefix}.largest_shift_target`]: largestShiftTarget,
        [`${attrPrefix}.element`]: largestShiftTarget,
        [`${attrPrefix}.largest_shift_time`]: largestShiftTime,
        [`${attrPrefix}.largest_shift_value`]: largestShiftValue,
        [`${attrPrefix}.load_state`]: loadState,
        [`${attrPrefix}.had_recent_input`]: largestShiftEntry === null || largestShiftEntry === void 0 ? void 0 : largestShiftEntry.hadRecentInput
      }));
      if (applyCustomAttributes) {
        applyCustomAttributes(cls, span);
      }
      span.end();
    };
    this.onReportLCP = (lcp, lcpOpts = {}) => {
      const {
        applyCustomAttributes,
        dataAttributes
      } = lcpOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = lcp;
      const {
        element,
        url,
        timeToFirstByte,
        resourceLoadDelay,
        resourceLoadDuration,
        elementRenderDelay,
        lcpEntry
      } = attribution;
      const attrPrefix = this.getAttrPrefix(name);
      const span = this.tracer.startSpan(name);
      span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(lcp)), {
        [`${attrPrefix}.element`]: element,
        [`${attrPrefix}.url`]: url,
        [`${attrPrefix}.time_to_first_byte`]: timeToFirstByte,
        [`${attrPrefix}.resource_load_delay`]: resourceLoadDelay,
        [`${attrPrefix}.resource_load_duration`]: resourceLoadDuration,
        [`${attrPrefix}.element_render_delay`]: elementRenderDelay,
        // This will be deprecated in a future version
        [`${attrPrefix}.resource_load_time`]: resourceLoadDuration
      }));
      const el = lcpEntry === null || lcpEntry === void 0 ? void 0 : lcpEntry.element;
      if (el === null || el === void 0 ? void 0 : el.dataset) {
        for (const attrName in el.dataset) {
          const attrValue = el.dataset[attrName];
          if (
          // Value exists (including the empty string AND either
          attrValue !== undefined && (
          // dataAttributes is undefined (i.e. send all values as span attributes) OR
          dataAttributes === undefined ||
          // dataAttributes is specified AND attrName is in dataAttributes (i.e attribute name is in the supplied allowList)
          dataAttributes.includes(attrName))) {
            span.setAttribute(`${attrPrefix}.element.data.${attrName}`, attrValue);
          }
        }
      }
      if (applyCustomAttributes) {
        applyCustomAttributes(lcp, span);
      }
      span.end();
    };
    this.onReportINP = (inp, inpOpts = {
      includeTimingsAsSpans: false
    }) => {
      const {
        applyCustomAttributes,
        includeTimingsAsSpans
      } = inpOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = inp;
      const {
        inputDelay,
        interactionTarget,
        interactionTime,
        interactionType,
        loadState,
        nextPaintTime,
        presentationDelay,
        processingDuration,
        longAnimationFrameEntries: _loafEntries
      } = attribution;
      const longAnimationFrameEntries = _loafEntries;
      const attrPrefix = this.getAttrPrefix(name);
      const inpDuration = inputDelay + processingDuration + presentationDelay;
      this.tracer.startActiveSpan(name, {
        startTime: interactionTime
      }, inpSpan => {
        const inpAttributes = Object.assign(Object.assign({}, this.getSharedAttributes(inp)), {
          [`${attrPrefix}.input_delay`]: inputDelay,
          [`${attrPrefix}.interaction_target`]: interactionTarget,
          [`${attrPrefix}.interaction_time`]: interactionTime,
          [`${attrPrefix}.interaction_type`]: interactionType,
          [`${attrPrefix}.load_state`]: loadState,
          [`${attrPrefix}.next_paint_time`]: nextPaintTime,
          [`${attrPrefix}.presentation_delay`]: presentationDelay,
          [`${attrPrefix}.processing_duration`]: processingDuration,
          [`${attrPrefix}.duration`]: inpDuration,
          // These will be deprecated in a future version
          [`${attrPrefix}.element`]: interactionTarget,
          [`${attrPrefix}.event_type`]: interactionType
        });
        inpSpan.setAttributes(inpAttributes);
        if (applyCustomAttributes) {
          applyCustomAttributes(inp, inpSpan);
        }
        if (includeTimingsAsSpans) {
          longAnimationFrameEntries.forEach(perfEntry => {
            this.processPerformanceLongAnimationFrameTimingSpans(attrPrefix, perfEntry);
          });
        }
        inpSpan.end(interactionTime + inpDuration);
      });
    };
    this.onReportFCP = (fcp, fcpOpts = {}) => {
      const {
        applyCustomAttributes
      } = fcpOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = fcp;
      const {
        timeToFirstByte,
        firstByteToFCP,
        loadState
      } = attribution;
      const attrPrefix = this.getAttrPrefix(name);
      const span = this.tracer.startSpan(name);
      span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(fcp)), {
        [`${attrPrefix}.time_to_first_byte`]: timeToFirstByte,
        [`${attrPrefix}.time_since_first_byte`]: firstByteToFCP,
        [`${attrPrefix}.load_state`]: loadState
      }));
      if (applyCustomAttributes) {
        applyCustomAttributes(fcp, span);
      }
      span.end();
    };
    /**
     *  @deprecated this will be removed in the next major version, use INP instead.
     */
    this.onReportFID = (fid, fidOpts = {}) => {
      const {
        applyCustomAttributes
      } = fidOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = fid;
      const {
        eventTarget,
        eventType,
        loadState
      } = attribution;
      const attrPrefix = this.getAttrPrefix(name);
      const span = this.tracer.startSpan(name);
      span.setAttributes(Object.assign(Object.assign({}, this.getSharedAttributes(fid)), {
        [`${attrPrefix}.element`]: eventTarget,
        [`${attrPrefix}.event_type`]: eventType,
        [`${attrPrefix}.load_state`]: loadState
      }));
      if (applyCustomAttributes) {
        applyCustomAttributes(fid, span);
      }
      span.end();
    };
    this.onReportTTFB = (ttfb, ttfbOpts = {}) => {
      const {
        applyCustomAttributes
      } = ttfbOpts;
      if (!this.isEnabled()) return;
      const {
        name,
        attribution
      } = ttfb;
      const {
        cacheDuration,
        connectionDuration,
        dnsDuration,
        requestDuration,
        waitingDuration
      } = attribution;
      const attrPrefix = this.getAttrPrefix(name);
      const attributes = Object.assign(Object.assign({}, this.getSharedAttributes(ttfb)), {
        [`${attrPrefix}.waiting_duration`]: waitingDuration,
        [`${attrPrefix}.dns_duration`]: dnsDuration,
        [`${attrPrefix}.connection_duration`]: connectionDuration,
        [`${attrPrefix}.request_duration`]: requestDuration,
        [`${attrPrefix}.cache_duration`]: cacheDuration,
        // These will be deprecated ina future version
        [`${attrPrefix}.waiting_time`]: waitingDuration,
        [`${attrPrefix}.dns_time`]: dnsDuration,
        [`${attrPrefix}.connection_time`]: connectionDuration,
        [`${attrPrefix}.request_time`]: requestDuration
      });
      const span = this.tracer.startSpan(name);
      span.setAttributes(attributes);
      if (applyCustomAttributes) {
        applyCustomAttributes(ttfb, span);
      }
      span.end();
    };
    this.vitalsToTrack = [...vitalsToTrack];
    this.lcpOpts = lcp;
    this.clsOpts = cls;
    this.inpOpts = inp;
    this.fidOpts = fid;
    this.fcpOpts = fcp;
    this.ttfbOpts = ttfb;
    this._isEnabled = enabled;
    this._setupWebVitalsCallbacks();
  }
  init() {}
  _setupWebVitalsCallbacks() {
    if (this.vitalsToTrack.includes('CLS')) {
      D(vital => {
        this.onReportCLS(vital, this.clsOpts);
      }, this.clsOpts);
    }
    if (this.vitalsToTrack.includes('LCP')) {
      ot(vital => {
        this.onReportLCP(vital, this.lcpOpts);
      }, this.lcpOpts);
    }
    if (this.vitalsToTrack.includes('INP')) {
      rt(vital => {
        this.onReportINP(vital, this.inpOpts);
      }, this.inpOpts);
    }
    if (this.vitalsToTrack.includes('FID')) {
      yt(vital => {
        this.onReportFID(vital, this.fidOpts);
      }, this.fidOpts);
    }
    if (this.vitalsToTrack.includes('TTFB')) {
      ft(vital => {
        this.onReportTTFB(vital, this.ttfbOpts);
      }, this.ttfbOpts);
    }
    if (this.vitalsToTrack.includes('FCP')) {
      w(vital => {
        this.onReportFCP(vital, this.fcpOpts);
      }, this.fcpOpts);
    }
  }
  getAttrPrefix(name) {
    return name.toLowerCase();
  }
  getSharedAttributes(vital) {
    const {
      name,
      id,
      delta,
      rating,
      value,
      navigationType
    } = vital;
    const attrPrefix = this.getAttrPrefix(name);
    return {
      [`${attrPrefix}.id`]: id,
      [`${attrPrefix}.delta`]: delta,
      [`${attrPrefix}.value`]: value,
      [`${attrPrefix}.rating`]: rating,
      [`${attrPrefix}.navigation_type`]: navigationType
    };
  }
  getAttributesForPerformanceLongAnimationFrameTiming(prefix, perfEntry) {
    const loafAttributes = {
      [`${prefix}.duration`]: perfEntry.duration,
      [`${prefix}.entryType`]: perfEntry.entryType,
      [`${prefix}.name`]: perfEntry.name,
      [`${prefix}.renderStart`]: perfEntry.renderStart,
      [`${prefix}.startTime`]: perfEntry.startTime
    };
    return loafAttributes;
  }
  getAttributesForPerformanceScriptTiming(prefix, scriptPerfEntry) {
    const scriptAttributes = {
      [`${prefix}.entry_type`]: scriptPerfEntry.entryType,
      [`${prefix}.start_time`]: scriptPerfEntry.startTime,
      [`${prefix}.execution_start`]: scriptPerfEntry.executionStart,
      [`${prefix}.duration`]: scriptPerfEntry.duration,
      [`${prefix}.forced_style_and_layout_duration`]: scriptPerfEntry.forcedStyleAndLayoutDuration,
      [`${prefix}.invoker`]: scriptPerfEntry.invoker,
      [`${prefix}.pause_duration`]: scriptPerfEntry.pauseDuration,
      [`${prefix}.source_url`]: scriptPerfEntry.sourceURL,
      [`${prefix}.source_function_name`]: scriptPerfEntry.sourceFunctionName,
      [`${prefix}.source_char_position`]: scriptPerfEntry.sourceCharPosition,
      [`${prefix}.window_attribution`]: scriptPerfEntry.windowAttribution
    };
    return scriptAttributes;
  }
  processPerformanceLongAnimationFrameTimingSpans(parentPrefix, perfEntry) {
    if (!perfEntry) return;
    const prefix = `${parentPrefix}.timing`;
    const loafAttributes = this.getAttributesForPerformanceLongAnimationFrameTiming(prefix, perfEntry);
    this.tracer.startActiveSpan(perfEntry.name, {
      startTime: perfEntry.startTime
    }, span => {
      span.setAttributes(loafAttributes);
      this.processPerformanceScriptTimingSpans(prefix, perfEntry.scripts);
      span.end(perfEntry.startTime + perfEntry.duration);
    });
  }
  processPerformanceScriptTimingSpans(parentPrefix, perfScriptEntries) {
    if (!perfScriptEntries) return;
    if (!(perfScriptEntries === null || perfScriptEntries === void 0 ? void 0 : perfScriptEntries.length)) return;
    const prefix = `${parentPrefix}.script`;
    perfScriptEntries.map(scriptPerfEntry => {
      this.tracer.startActiveSpan(scriptPerfEntry.name, {
        startTime: scriptPerfEntry.startTime
      }, span => {
        const scriptAttributes = this.getAttributesForPerformanceScriptTiming(prefix, scriptPerfEntry);
        span.setAttributes(scriptAttributes);
        span.end(scriptPerfEntry.startTime + scriptPerfEntry.duration);
      });
    });
  }
  disable() {
    if (!this.isEnabled()) {
      this._diag.debug(`Instrumentation already disabled`);
      return;
    }
    this._isEnabled = false;
    this._diag.debug(`Instrumentation  disabled`);
  }
  enable() {
    if (this.isEnabled()) {
      this._diag.debug(`Instrumentation already enabled`);
      return;
    }
    this._isEnabled = true;
    this._diag.debug(`Instrumentation  enabled`);
    this._diag.debug(`Sending spans for ${this.vitalsToTrack.join(',')}`);
  }
  isEnabled() {
    return this._isEnabled;
  }
}

/**
 * Global errors auto-instrumentation, sends spans automatically for exceptions that reach the window.
 * @param config The {@link GlobalErrorsInstrumentationConfig}
 */
class GlobalErrorsInstrumentation extends InstrumentationAbstract {
  constructor({
    enabled = true
  } = {}) {
    const config = {
      enabled
    };
    super('@honeycombio/instrumentation-global-errors', VERSION, config);
    this.onError = event => {
      const error = 'reason' in event ? event.reason : event.error;
      const message = error === null || error === void 0 ? void 0 : error.message;
      const type = error === null || error === void 0 ? void 0 : error.name;
      const attributes = {
        [semanticConventions.SEMATTRS_EXCEPTION_TYPE]: type,
        [semanticConventions.SEMATTRS_EXCEPTION_MESSAGE]: message,
        [semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE]: error === null || error === void 0 ? void 0 : error.stack
      };
      // otel spec requires at minimum these two
      if (!message || !type) return;
      const errorSpan = this.tracer.startSpan('exception', {
        attributes
      }, api.context.active());
      errorSpan.setStatus({
        code: api.SpanStatusCode.ERROR,
        message
      });
      errorSpan.end();
    };
    if (enabled) {
      this.enable();
    }
    this._isEnabled = enabled;
  }
  init() {}
  disable() {
    if (!this.isEnabled()) {
      this._diag.debug(`Instrumentation already disabled`);
      return;
    }
    this._isEnabled = false;
    window.removeEventListener('error', this.onError);
    window.removeEventListener('unhandledrejection', this.onError);
    this._diag.debug(`Instrumentation  disabled`);
  }
  enable() {
    if (this.isEnabled()) {
      this._diag.debug(`Instrumentation already enabled`);
      return;
    }
    this._isEnabled = true;
    window.addEventListener('error', this.onError);
    window.addEventListener('unhandledrejection', this.onError);
    this._diag.debug(`Instrumentation  enabled`);
  }
  isEnabled() {
    return this._isEnabled;
  }
}

class HoneycombWebSDK extends WebSDK {
  constructor(options) {
    var _a, _b;
    const instrumentations = [...((options === null || options === void 0 ? void 0 : options.instrumentations) || [])];
    // Automatically include web vitals instrumentation unless explicitly set to false
    if (((_a = options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig) === null || _a === void 0 ? void 0 : _a.enabled) !== false) {
      instrumentations.push(new WebVitalsInstrumentation(options === null || options === void 0 ? void 0 : options.webVitalsInstrumentationConfig));
    }
    // Automatically include global errors instrumentation unless explicitly set to false
    if (((_b = options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig) === null || _b === void 0 ? void 0 : _b.enabled) !== false) {
      instrumentations.push(new GlobalErrorsInstrumentation(options === null || options === void 0 ? void 0 : options.globalErrorsInstrumentationConfig));
    }
    super(Object.assign(Object.assign({}, options), {
      instrumentations,
      resource: mergeResources([configureBrowserAttributesResource(), configureEntryPageResource(options === null || options === void 0 ? void 0 : options.entryPageAttributes), options === null || options === void 0 ? void 0 : options.resource, options === null || options === void 0 ? void 0 : options.resourceAttributes, configureHoneycombResource()]),
      sampler: configureDeterministicSampler(options),
      // Exporter is configured through the span processor because
      // the base SDK does not allow having both a spanProcessor and a
      // traceExporter configured at the same time.
      spanProcessor: configureSpanProcessors(options)
    }));
    validateOptionsWarnings(options);
    if (options === null || options === void 0 ? void 0 : options.debug) {
      configureDebug(options);
    }
  }
}

exports.HoneycombWebSDK = HoneycombWebSDK;
exports.InstrumentationAbstract = InstrumentationAbstract;
exports.WebSDK = WebSDK;
exports.WebVitalsInstrumentation = WebVitalsInstrumentation;
