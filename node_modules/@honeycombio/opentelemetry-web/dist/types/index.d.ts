import * as _opentelemetry_api from '@opentelemetry/api';
import { DiagLogger, Meter, MeterProvider, TracerProvider, Tracer, Span, ContextManager, TextMapPropagator, DiagLogLevel } from '@opentelemetry/api';
import { Instrumentation, InstrumentationConfig } from '@opentelemetry/instrumentation';
import { IResource, Detector, DetectorSync, ResourceAttributes } from '@opentelemetry/resources';
import { Sampler, SpanProcessor, SpanExporter, SpanLimits, IdGenerator } from '@opentelemetry/sdk-trace-base';
import { Metric, CLSMetricWithAttribution, LCPMetricWithAttribution, INPMetricWithAttribution, FCPMetricWithAttribution, FIDMetricWithAttribution, TTFBMetricWithAttribution, ReportOpts } from 'web-vitals/attribution';

type ApplyCustomAttributesFn = (vital: Metric, span: Span) => void;
interface VitalOpts extends ReportOpts {
    /**
     * Callback function to add custom attributes to web vitals span.
     * @example
     * (vital, span) => {
     *   // a value under 3000ms is acceptable as a 'good' rating for our team
     *   // this would otherwise show up as 'needs-improvement' if the value is less than 2500 in 'lcp.rating' according to the
     *   // set standards but we want to record this as well.
     *   if (vital.value < 3000) {
     *     span.setAttribute('lcp.custom_rating', 'good');
     *  }
     * }
     */
    applyCustomAttributes?: ApplyCustomAttributesFn;
}
interface LcpVitalOpts extends VitalOpts {
    /**
     * Will filter the values of these data attributes if provided, otherwise will send all data-* attributes an LCP entry
     * An empty allow list, such as { dataAttributes: [] } will disable sending data-* attributes
     */
    dataAttributes?: string[];
}
interface InpVitalOpts extends VitalOpts {
    /**
     * if this is true it will create spans from the PerformanceLongAnimationFrameTiming frames
     */
    includeTimingsAsSpans?: boolean;
}
declare abstract class InstrumentationAbstract implements Instrumentation {
    readonly instrumentationName: string;
    readonly instrumentationVersion: string;
    protected _config: InstrumentationConfig;
    private _tracer;
    private _meter;
    protected _diag: DiagLogger;
    constructor(instrumentationName: string, instrumentationVersion: string, config?: InstrumentationConfig);
    protected _wrap: <Nodule extends object, FieldName extends keyof Nodule>(nodule: Nodule, name: FieldName, wrapper: (original: Nodule[FieldName]) => Nodule[FieldName]) => void;
    protected _unwrap: <Nodule extends object>(nodule: Nodule, name: keyof Nodule) => void;
    protected _massWrap: <Nodule extends object, FieldName extends keyof Nodule>(nodules: Nodule[], names: FieldName[], wrapper: (original: Nodule[FieldName]) => Nodule[FieldName]) => void;
    protected _massUnwrap: <Nodule extends object>(nodules: Nodule[], names: Array<keyof Nodule>) => void;
    protected get meter(): Meter;
    /**
     * Sets MeterProvider to this plugin
     * @param meterProvider
     */
    setMeterProvider(meterProvider: MeterProvider): void;
    /**
     * Sets the new metric instruments with the current Meter.
     */
    protected _updateMetricInstruments(): void;
    getConfig(): InstrumentationConfig;
    /**
     * Sets InstrumentationConfig to this plugin
     * @param InstrumentationConfig
     */
    setConfig(config?: InstrumentationConfig): void;
    /**
     * Sets TraceProvider to this plugin
     * @param tracerProvider
     */
    setTracerProvider(tracerProvider: TracerProvider): void;
    protected get tracer(): Tracer;
    abstract enable(): void;
    abstract disable(): void;
    /**
     * Init method in which plugin should define _modules and patches for
     * methods
     */
    protected abstract init(): void;
}
interface WebVitalsInstrumentationConfig extends InstrumentationConfig {
    /** Array of web vitals to send spans for, defaults to ["CLS", "LCP", "INP"] if not specified. */
    vitalsToTrack?: Array<Metric['name']>;
    /** Config specific to LCP (Largest Contentful Paint) */
    lcp?: LcpVitalOpts;
    /** Config specific to CLS (Cumulative Layout Shift) */
    cls?: VitalOpts;
    /** Config specific to INP (Interaction to Next Paint) */
    inp?: InpVitalOpts;
    /** Config specific to FID (First Input Delay) */
    fid?: VitalOpts;
    /** Config specific to FCP (First Contentful Paint) */
    fcp?: VitalOpts;
    /** Config specific to TTFB (Time To First Byte) */
    ttfb?: VitalOpts;
}
/**
 * Web vitals auto-instrumentation, sends spans automatically for CLS, LCP, INP, FCP, FID, TTFB.
 * Defaults to sending spans for CLS, LCP, INP, FCP and TTFB.
 * @param config The {@link WebVitalsInstrumentationConfig }
 */
declare class WebVitalsInstrumentation extends InstrumentationAbstract {
    readonly vitalsToTrack: Array<Metric['name']>;
    readonly lcpOpts?: LcpVitalOpts;
    readonly clsOpts?: VitalOpts;
    readonly inpOpts?: InpVitalOpts;
    readonly fidOpts?: VitalOpts;
    readonly fcpOpts?: VitalOpts;
    readonly ttfbOpts?: VitalOpts;
    private _isEnabled;
    constructor({ enabled, vitalsToTrack, lcp, cls, inp, fid, fcp, ttfb, }?: WebVitalsInstrumentationConfig);
    init(): void;
    private _setupWebVitalsCallbacks;
    private getAttrPrefix;
    private getSharedAttributes;
    private getAttributesForPerformanceLongAnimationFrameTiming;
    private getAttributesForPerformanceScriptTiming;
    private processPerformanceLongAnimationFrameTimingSpans;
    private processPerformanceScriptTimingSpans;
    onReportCLS: (cls: CLSMetricWithAttribution, clsOpts?: VitalOpts) => void;
    onReportLCP: (lcp: LCPMetricWithAttribution, lcpOpts?: LcpVitalOpts) => void;
    onReportINP: (inp: INPMetricWithAttribution, inpOpts?: InpVitalOpts) => void;
    onReportFCP: (fcp: FCPMetricWithAttribution, fcpOpts?: VitalOpts) => void;
    /**
     *  @deprecated this will be removed in the next major version, use INP instead.
     */
    onReportFID: (fid: FIDMetricWithAttribution, fidOpts?: VitalOpts) => void;
    onReportTTFB: (ttfb: TTFBMetricWithAttribution, ttfbOpts?: VitalOpts) => void;
    disable(): void;
    enable(): void;
    isEnabled(): boolean;
}

interface GlobalErrorsInstrumentationConfig extends InstrumentationConfig {
}

interface WebSDKConfiguration {
    autoDetectResources: boolean;
    contextManager: ContextManager;
    textMapPropagator: TextMapPropagator;
    instrumentations: (Instrumentation | Instrumentation[])[];
    resource: IResource;
    resourceDetectors: Array<Detector | DetectorSync>;
    sampler: Sampler;
    serviceName?: string;
    spanProcessor: SpanProcessor;
    traceExporter: SpanExporter;
    spanLimits: SpanLimits;
    idGenerator: IdGenerator;
}
/**
 * The options used to configure the Honeycomb Web SDK.
 */
interface HoneycombOptions extends Partial<WebSDKConfiguration> {
    /** Honeycomb API key for sending traces directly to Honeycomb */
    apiKey?: string;
    /** Honeycomb API key for sending traces telemetry to Honeycomb. Defaults to apiKey if not set. */
    tracesApiKey?: string;
    /** The API endpoint where telemetry is sent. Defaults to 'https://api.honeycomb.io/v1/traces'.
     * Appends `/v1/traces` to the endpoint provided.
     */
    endpoint?: string;
    /** Optionally pass extra headers to the exporter. Commonly used if sending to a collector that requires authentication */
    headers?: {
        [key: string]: string | number;
    };
    /** The API endpoint where traces telemetry is sent. Defaults to endpoint if not set. */
    tracesEndpoint?: string;
    /** The dataset where traces telemetry is stored in Honeycomb. Only required when using a classic API key.
     * https://docs.honeycomb.io/honeycomb-classic/#am-i-using-honeycomb-classic
     */
    dataset?: string;
    /** The service name of the application and where traces telemetry is stored in Honeycomb.
     * Defaults to `unknown_service`
     */
    serviceName?: string;
    /** Provide an array of span processors that should be applied to all spans.
     * Use this to specify synchronous hooks that can add to a span once the span is started or ended.
     * The processors will be applied in the order they are specified.
     * E.g. adding attributes to a span.
     */
    spanProcessors?: SpanProcessor[];
    /** Provide an array of exporters
     * Use this to configure custom tracing services in addition
     * to the default honeycomb one.
     * E.g. You want to send data to another service.
     */
    traceExporters?: SpanExporter[];
    /** Disable the default honeycomb SpanExporters
     * `true` Disables the default honeycomb span exporter, `false` enables.
     * in this case you should provide other exporters in the `traceExporters` field.
     * Defaults to 'false'.
     */
    disableDefaultTraceExporter?: boolean;
    /** The sample rate used to determine whether a trace is exported.
     * This must be a whole positive number. Only 1 out of every `sampleRate` traces will be randomly selected to be sent.
     * Set to 0 to drop everything.
     * Defaults to 1 (send everything).
     */
    sampleRate?: number;
    /** The debug flag enables additional logging that is useful when debugging your application. Do not use in production.
     * Defaults to 'false'.
     */
    debug?: boolean;
    /** Additional attributes, will be included as fields on all data */
    resourceAttributes?: ResourceAttributes;
    /** The local visualizations flag enables logging Honeycomb URLs for completed traces. Do not use in production.
     * Defaults to 'false'.
     */
    localVisualizations?: boolean;
    /** Skip options validation warnings (eg no API key configured). This is useful when the SDK is being
     * used in conjunction with an OpenTelemetry Collector (which will handle the API key and dataset configuration).
     * Defaults to 'false'.
     */
    skipOptionsValidation?: boolean;
    /** Configuration for entry page attributes: set to false to disable entirely, or pass in a custom config
     * to fine-tune the included attributes.
     *
     * Defaults to
     * ```
     * {
     *  path: true,
     *  hash: true,
     *  hostname: true,
     *  referrer: true,
     *  url: false,
     *  search: false
     * }
     * ```
     */
    entryPageAttributes?: false | EntryPageConfig;
    /** Config options for web vitals instrumentation. Enabled by default. */
    webVitalsInstrumentationConfig?: WebVitalsInstrumentationConfig;
    globalErrorsInstrumentationConfig?: GlobalErrorsInstrumentationConfig;
    /**
     * Controls the verbosity of logs. Utilizes OpenTelemetry's `DiagLogLevel` enum. Defaults to 'DEBUG'.
     * Current options include 'NONE', 'ERROR', 'WARN', 'INFO', 'DEBUG', 'VERBOSE', and 'ALL'.
     */
    logLevel?: DiagLogLevel;
}
type EntryPageConfig = {
    /** Include the path: '/working-with-your-data/overview/'
     * Defaults to 'true' */
    path?: boolean;
    /** Include the hash: '#view-events'
     * Defaults to 'true' */
    hash?: boolean;
    /** Include the hostname: 'docs.honeycomb.io'
     * Defaults to 'true' */
    hostname?: boolean;
    /** Include the document.referrer: 'https://example.com/page-with-referring-link'
     * Defaults to 'true' */
    referrer?: boolean;
    /** Include the full url.
     * 'https://docs.honeycomb.io/working-with-your-data/overview/#view-events?page=2'
     *
     * Defaults to 'false' */
    url?: boolean;
    /** Include the search params: '?page=2'
     * Defaults to 'false' */
    search?: boolean;
};

/** This class represents everything needed to register a fully configured OpenTelemetry Web SDK */
declare class WebSDK {
    private _tracerProviderConfig?;
    private _instrumentations;
    private _resource;
    private _resourceDetectors;
    private _autoDetectResources;
    private _tracerProvider?;
    private _serviceName?;
    private _disabled?;
    /**
     * Create a new Web SDK instance
     */
    constructor(configuration?: Partial<WebSDKConfiguration>);
    /**
     * Call this method to construct SDK components and register them with the OpenTelemetry API.
     */
    start(): void;
    getResourceAttributes(): _opentelemetry_api.Attributes;
    shutdown(): Promise<void>;
}

declare class HoneycombWebSDK extends WebSDK {
    constructor(options?: HoneycombOptions);
}

export { HoneycombWebSDK, InstrumentationAbstract, WebSDK, WebVitalsInstrumentation, type WebVitalsInstrumentationConfig };
